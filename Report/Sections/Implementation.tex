\section{Components and Implementation} \label{sec:impl}
(Block diagram)
The whole computing system is composed by three main modules (CPU, RAM and LCD debug module)
and by various other auxiliary modules.
The CPU comprises various 8-bit registers and uses them to fetch data from the RAM module, process it and, eventually write it on the RAM.
The LCD Debug driver allows to access both the stored RAM bytes and the CPU registers from the LCD screen.
North and East pushbuttons are stabilized and used along with a switch to change the CPU registers or RAM values shown on the screen.
Both the CPU and RAM run on three different clocks: a 50 MHz "Master" synchronization clock,
 a 1kHz debug clock used to comunicate with the LCD driver independently from the other operations
 and a last clock, sourced via the South pushbutton, and used to govern the actual computations and input/output operations between CPU and RAM.
The RAM is pre-loaded with the data and instructions during the FPGA configuration phase.



\subsection{CPU Module}  \label{ssec:cpu}
*Block scheme/image of CPU internal registers and buses*
*scheme of states for some instructions? (initial 3 states, then example of other instructions)*

The CPU module behaves like a state machine which fetches and executes one instruction at time from the RAM in the form of single-byte operation codes ("opcodes").
If the instruction requires it, the CPU can also fetch other bytes as parameters..
Each instruction execution is divided into several states, kept track by the \code{state} register.
Various other 8-bit registers are present to help store, process and write data.
At each \code{clk\_in} edge risetime, the module behaviour is determined by the current instruction and state.
When the last state corresponding to an instruction is reached, \code{state} register is reset to 0 and the process
restart by fetching the next instruction.

In general, the instruction fetch-execution cycle behaves as follows:
\begin{itemize}
    \item \code{state} 0-2: The next instruction is fetched from the memory location pointed by the Program Counter (\code{PC}) and placed in the Instruction Register (\texttt{IR}).
    \item \code{state} 3- : The instruction is executed, eventually by reading or writing other bytes from memory or by operating on the internal registers. At the end, the \code{PC} address is incremented by one and \code{state} is reset to 0. The cycle then restarts
\end{itemize}

The following is a list of the internal CPU module registers:
\begin{itemize}
    \item \code{PC}: (8-bit) Program Counter, contains the memory address to the next instruction.
    \item \code{IR}: (8-bit) Instruction Register, Contains the byte corresponding to the current instruction in execution
    \item \code{A}: (8-bit) Accumulator, Register used to store fetched data and used by default as result recipient by the ADD instruction
    \item \code{B,C}: (8-bit) General purpose registers
    \item \code{W,Z}: (8-bit) Temporary registers for internal instruction operations, not directly accessible via instructions
    \item \code{H,L}: (8-bit) Registers used to store memory addresses, for instance used to write from register to referenced memory location
    \item \code{data\_addr,data\_out,write\_en}: Registers connected to output wirebuses, used to communicate read/write informations to RAM
    \item \code{flg\_carry,flg\_sign,flg\_zero,flg\_parity,flg\_auxiliary}: Various flags registers used to keep track of the results of the instructions.
    \code{flg\_auxiliary} is used as general-purpose flag to reduce the number of required instructions.
\end{itemize}

As a side note, the input/output operations usually require additional "buffering" times (blank states) to allow address informations delivery or data fetches.

\subsection{RAM Module}  \label{ssec:ram}
The \code{Module\_BRAM\_256\_byte} module is based on the usage of the "Block Ram" modules present in the Xilinx Spartan 3A.
From the logical and Verilog code points of view, the Block RAM cells can be declared as arrays of $n$-bit registers.
In this specific module, the Block ram used is organized as an array of 256 8-bit memory cells, corresponding to a memory with 8-bit addresses.
The memory content is initialized using the Verilog command:
\begin{verbatim}
initial
begin
	$readmemh("memory.data", RAM, 0, 255);
end
\end{verbatim}
which prescribes how to load the RAM content from the file \code{memory.data} during the device configuration phase.

At each \code{clk\_in} tick, the RAM either reads or writes the content at address \code{addr} according to \code{write\_en}
by using the wires/registers \code{data\_in}, \code{data\_out}


\subsection{LCD driver Module}  \label{ssec:lcd}
The \code{LCD\_Driver\_Dbg} module is used to visualize the content of both the RAM module and the internal CPU registers.
The informations to be shown on display are inputed via the \code{addrInput, dataInput, CPU\_interface, dbg\_reg} wirebuses.
The user can select via switch one of the two devices, and further use the North and East buttons to move between the memory addresses
or CPU registers (implemented via a "Ladder" counter).
These informations are then passed to the here considered module via \code{addrInput} and \code{dbg\_reg}.

The LCD screen comprises a display data RAM used to store the shown characters,
and communicates with the FPGA board via the following lines:
\begin{itemize}
    \item \code{LCD\_DB}: an 8-bit "Data bit" wirebus. Here is used in 4-bit mode, therefore the lower 4 bits are set to high. 
    4-bit mode requires to perform all the operations by sending separately the upper and lower nible of each 8-bit signal.
    \item \code{LCD\_E}: single-bit Read/write enable pulse, used to comunicate to the display that the other buses are rady for operating.
    \item \code{LCD\_RS}: single-bit register select.
    \item \code{LCD\_RW}: read/write control, here permanetly set to 0 for write-only mode
\end{itemize}
Operating the LCD screen via Driver requires the following steps:
\begin{itemize}
    \item Power-on initialization: initialization phase, the data bits are set and \code{LCD\_E} is pulsed according to required patterns and timings.
    \item Display configurations: Here multiple commands are issued to configure the device functioning:
    \begin{itemize}
        \item Function set
        \item Entry mode set: address counter is set to auto-increment
        \item Display on, cursor and blinking are set off
        \item Clear Display
    \end{itemize}
    \item Character writing
\end{itemize}

Disclaimer: the LCD driver module here used is based on a modified version of code not originally writtend by the author.